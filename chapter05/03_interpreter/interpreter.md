### Interpreter

**의도**

: 어떤 문법이 있는 언어(작은 도메인 언어)에 대해, 그 언어의 문법 구조(표현)를 정의하고,

그 문법을 사용해서 만들어진 문장이나 식을 해석하는 로직(해석자)도 함께 정의하는 패턴

**동기**
:같은 종류의 문제가 반복적으로 발생하고 있을 때, 문제를 해결하기 위한 단순하고 간결한 규칙이나 언어를 정의 그리고 그런 언어로 표현된 문장을 해석할 수 있는 해석자(Interpreter)를 만들어서, 실제로 그 문장을 처리하거나, 해석하게 할 수 있다. 예: 정규 표현식

**활용성**

<해석자 패턴이 가장 잘 먹힐 때>
-정의할 언어의 문법이 간단할 때

-파스트리(구문트리)를 직접 해석하는 대신, 중간 단계로 변환해서 더 쉽게 처리할 수 있는 형태로 바꿔서 해석하는 방식일 때

**구조**

**참여자**

- AbstractExpression
    - 해석자 패턴에서 **모든 표현식**이 따라야 할 공통적인 인터페이스를 정의
    - **구문 트리의 각 노드**가 **`interpret()`** 메서드를 구현해야 한다.
- TerminalExpression
    - **터미널 노드**에서 `interpret()` 메서드를 구현
    - **문법에서 더 이상 분해할 수 없는 기본적인 요소**를 의미
- NonterminalExpression
    - **문법의 규칙**에 맞는 **비터미널 노드**를 정의
    - **두 개 이상의 터미널 심볼**이나 **다른 비터미널 심볼**을 결합하는 **연산자**를 처리
- Context: 해석을 진행할 때 필요한 **전역적 정보**를 제공
- Client: 문법 규칙에 맞는 추상 구문 트리(Abstract Syntax Tree, AST)를 만들고, 그 트리에 대해 **interpret()** 메서드를 호출하여 해석을 실행

**협력 방법**

- 사용자는 NonterminalExpression과  TerminalExpression 인스턴스들로 해당 문장에 대한 추상 구문트리를 만든다. → **`interpret()`** 메서드 호출 및 해서넹 필요한 문맥 정보 초기화
- 각 NonterminalExpression 노드는 또 다른 서브 표현식에 대한 **`interpret()`**를 이용하여 자신의 **`interpret()`** 을 정의(NonterminalExpression 객체는 **서브 표현식**을 가질 수 있기 때문에 다른 **NonterminalExpression**이나 **TerminalExpression**을 포함할 수 있다)
- 각 노드에 정의한 **`interpret()`** 연산은 해석자의 상태를 저장하거나 그것을 알기 위해 문맥 정보 이용

**결과**

<장점>

1. 문법의 변경과 확장이 쉽다.
2. 문법의 구현이 용이하다

<단점>

1. 복잡한 문법은 관리하기 어렵다.
2. 표현식을 해석하는 새로운 방법을 추가 할 수 있다. → 새로운 해석 방식을 추가하려면 클래스를 변경하거나 새로 추가해야 하므로, 유연성은 있지만 변경이 필요할 수 있다.

**구현**

-추상 구문트리를 생성한다.

-**`interpret()`** 연산을 정의 한다.

-플라이급 패턴을 적용하여 단말 기호를 공유 한다.