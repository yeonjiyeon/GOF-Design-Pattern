### **객체지향 소프트웨어 설계**

-지금 갖고 있는 문제를 해결해야 하는 것을 넘어서 추후 재사용 할 수 있도록(혹은 최소한의 수정만으로) 일반적이고 포괄적으로 설계되어야 한다. 

→ 숙련자들의 반복된 패턴이 해결책이 될 수 있다! 이미 설계의 문제점들을 겪고 공통된 문제점들을 패턴화 한 것이기 때문에

추가적 요구사항에 따른 확장성에 대비하기 위해 재사용성이 중요한 것??

### **디자인 패턴**

-객체지향 소프트웨어를 설계할 때 겪는 특별한 문제에 대한 (유연성과 재사용성에 초점을 맞춰서) 간결하고 명확한 해결책
-패턴 이름 + 문제 + 해법 + 결과 

-특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스에 대한 설명

→ 올바른 설계를 빨리 만들 수 있도록 도와준다.

### **디자인 패턴 카탈로그**

**생성 패턴 (Creational Patterns)**

- 추상 팩토리 (Abstract Factory)
- 빌더 (Builder)
- 팩토리 메서드 (Factory Method)
- 프로토타입 (Prototype)
- 싱글턴 (Singleton)

**구조 패턴 (Structural Patterns)**

- 어댑터 (Adapter)
- 브리지 (Bridge)
- 컴포지트 (Composite)
- 데코레이터 (Decorator)
- 퍼사드 (Facade)
- 플라이웨이트 (Flyweight)
- 프록시 (Proxy)

**행위 패턴 (Behavioral Patterns)**

- 책임 연쇄 (Chain of Responsibility)
- 커맨드 (Command)
- 인터프리터 (Interpreter)
- 반복자 (Iterator)
- 중재자 (Mediator)
- 메멘토 (Memento)
- 옵저버 (Observer)
- 상태 (State)
- 전략 (Strategy)
- 템플릿 메서드 (Template Method)
- 방문자 (Visitor)

### **카탈로그 조직화**

**<패턴 분류 기준>**

1) 목적: 패턴이 무엇을 하는지 정의

- 생성: 객체 생성에 관여하는 것
- 구조: 클래스나 객체의 합성에 관한 패턴
- 행동: 클래스나 객체들이 상호작용하는 방법이나 책임의 분산하는 방법

2)범위: 클래스에 적용하는지 아니면 객체에 적용하는지를 구분

- 클래스 패턴
    - 클래스와 서브클래스 간의 관련성을 다루는 패턴
    - 컴파일 타입에 정적으로 결정
    - 클래스 관련성 이용
- 객체 패턴
    - 객체 관련성을 다루는 패턴
    - 런타임에 변경할 수 있으며 더 동적인 성격

### **디자인패턴을 이용하여 문제를 푸는 방법**

**적당한 객체 찾기**

사용자 ⇒ 요청 ⇒ 객체(데이터 + 프로시저(메시지, 연산)) 연산 수행
요청: 객체가 작동을 수행하는 유일한 방법

연산: 객체의 내부 데이터 상태를 변경하는 유일한 방법

→ 이러한 접근 제약 사항으로 객체 내부 상태는 캡슐화(외부에서 알 수 없음) 

객체지향 설계의 가장 어려운 부분은 시스템을 구성할 객체의 분할을 결정하는 것이다.

→ 캡슐화, 크기 정하기, 종속성, 유연성, 성능, 진화, 재사용성 등의 요인을 고려해야 한다.

→ 어떻게 고려하는가에 따라 서로 다른 방법으로 분할이 가능

객체지향 설계는 실세계와 대응 관계를 갖지 못할 때가 많다.

→ 실세계를 그대로 반영하는 모델링만 강조하면, 현재의 실세계만 반영하고 미래의 실세계는 반영할 수 없다.(추상화 해야 한다?)
→ 디자인 패턴을 통해 추상적인 개념을 이해하고, 이를 적절한 객체로 표현하는 데 도움을 준다

**객체의 크기 결정**

디자인 패턴으로 적당한 객체의 규모 결정

**객체 인터페이스의 명세**

모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값을 명세한다.

- 시그니처 : 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값
- 인터페이스: 객체가 정의하는 연산의 모든 시그니처들
- 타입: 특정 인터페이스를 나타낼 때 사용하는 이름,

→ 객체는 여러 타입을 가질 수 있고, 서로 다른 객체가 하나의 타입을 공유할 수도 있음

- 서브타입: 다른 인터페이스를 포함하는 인터페이스
- 슈퍼타입: 다른 인터페이스가 포함하는 인터페이스

→ 객체는 인터페이스로 자신을 드러낸다.

→ 동일한 인터페이스를 갖는 두 객체가 완전히 다른 구현을 가질 수 있다.

- 동적 바인딩: 요청이 어떻게 구현되어 어떤 결과를 만들어 낼지를 런타임 시 결정

→ 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있게 해준다. → 다형성

→디자인패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와준다.

→디자인패턴은 인터페이스 간의 관련성 정의, 특히 클래스 간 유사한 인터페이스를 정의하도록 하거나 클래스의 인터페이스에 여러 가지 제약을 정의

**객체 구현 명세하기**

1)클래스 상속 대 인터페이스 상속

객체의 클래스: 그 객체가 어떻게 구현되느냐, 객체의 내부 상태와 그 연산들의 구현을 정의

객체의 타입: 그 객체의 인터페이스, 그 객체가 응답할 수 있는 요청들의 집합을 정의

→ 하나의 객체는 여러 타입을 가질 수 있고, 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있다.
<클래스 상속 대 인터페이스 상속>

클래스 상속 

- 이미 정의된 객체의 구현을 바탕으로 한다.(코드와 내부 표현 구조 공유)

인터페이스 상속 

- 어떤 객체가 다른 객체 대신 사용될 수 는 경우를 지정하는 메커니즘

2)구현에 따르지 않고, 인터페이스에 따르는 프로그래밍

클래스 상속

- 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 가능성을 확장하려는 메커니즘 → 새로운 구현 비용x를 위한 것
- 동일한 인터페이스를 갖는 객체군을 정의하는 것 → 다형성을 끌어낼 수 있다.
- 모든 서브클래스들은 부모 클래스의 서브타입이 되는 것
- 추상클래스 정의하고 인터페이스 개념으로 객체를 다룰 때 이점
    - 객체 타입에 대해 알 필요 없다
    - 구현 클래스를 알 필요 없고, 추상 클래스만 알면 된다.

→ 구현이 아닌 인터페이스에 따라 프로그래밍한다.(디자인 패턴의 일반적인 방식)

**재사용을 실현 가능한 것으로**

상속 대 합성

클래스 상속

- 서브 클래싱: 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의
- 화이트박스 재사용: 부모클래스의 내부가 서브클래스에 공개
- 컴파일 시점에 정적으로 정의
- 단점
    - 런타임에 상속받은 부모 클래스 구현 변경 불가
    - 서브 클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속 받는다. → 캡슐화 파괴? → 서브클래스는 부모 클래스 구현에 종속

→ 추상클래스에서만 상속받도록 해야 한다. 

객체 합성

- 다른 객체를 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것
- 블랙트박스 재사용: 인터페이스를 통해서만 재사용
- 런타임에 동적으로 정의
- 객체가 다른 객체의 인터페이스만 바라보게 하기 때문에 인터페이스 정의에 더 많은 주의를 기울여야 한다. → 캡슐화 유지
- 동일한 타입은 런타임에 대체 가능

→ 객체 합성으로 더욱 재사용 가능한 설계를 만들 수 있다.

위임

- 두 객체가 하나의 요청 처리, 수신 객체가 연산 처리를 위임자에게 보낸다?
- 장점
    - 런타임에 행동의 복합을 가능하게 하고, 복합하는 방식도 변경해준다.
- 단점
    - 고도로 매개변수화 된 경우 정적인 소프트웨어 구조보다 이해하기 어렵다.

→ 고도로 표준화 된 패턴에서 사용하는 것이 최상

상속 대 매개변화된 타입

매개변수화 된 타입: 제네릭, 미리 정의하지 않은 타입을 매개변수로 제공

**런타임 및 컴파일 타임의 구조를 관계짓기**

집합

- 한 객체가 다른 객체를 소유하거나 그것에 책임진다는 의미.
- 객체 통합: 통합된 객체 및 그 객체를 소유한 객체의 생존주기가 똑같다.
- 인지 관계보다 강력한 영속성 개념을 갖는다.(더 정적이다.)

인지

- 한 객체가 단순히 다른 객체에 대해 알고 있음을 의미.
- 서로 연산을 요청할 수도 있지만 서로에 대한 책임은 x

→ 사용 목적에 따라 결정해야 한다.

**변화에 대비한 설계**

1. 특정 클래스에서 객체 생성: 객체 직접 생성 x
2. 특정 연산에 대한 의존성: 직접 코딩 방식 x - 컴파일 시점과 런타임 모두를 만족하면서  요청처리방식을 쉽게 변경할 수 있다.
3. 하드웨어와 소프트웨어 플랫폼에 대한 의존성
4. 객체 표현이나 구현에 대한 의존성: 사용자에게 객체의 표현이나 구현 방법에 관한 정보를 감춰야 한다.
5. 알고리즘 의존성: 변경이 가능한 알고리즘은 분리
6. 높은 결합도: 재사용성을 위해 약한 결합도 필요
7. 서브클래싱을 통한 기능 확장: 객체 합성과 위임이 상속보다 유연한 방법이다.
8. 클래스 변경이 편하지 목한 점 

### **디자인 패턴을 고르는 방법**

1. 패턴이 어떻게 문제를 해결하는지 파악: 적합한 객체, 객체 크기 결정, 객체의 인터페이스 명세화를 어떻게 하는지를 살펴서 
2. 패턴의 의도 부분 확인: 카탈로그 확인 후 비슷한 문제 찾아보기 
3. 패턴들 간의 관련성 파악: 그림1.1 참고
4. 비슷한 목적의 패턴을 모아서 공부: 마지막 각 패텬별 비교 결론 설명 확인
5. 재설계의 원인을 파악
6. 설계에서 가변성을 가져야 하는 부분 파악: 재설계 없이 변경하고 싶은 부분 파악 → 가변성을 갖는 부분을 별도의 개념으로 캡슐화 
표 1.2ghkrdls