### Decorator

**의도**

:(기존 객체를 건드리지 않고 )객체에 동적으로 새로운 책임을 추가 할 수 있는 패턴

**동기**

**: 데코레이터 패턴**은 객체에 새로운 기능을 동적으로 추가하는 방법이다. 이를 위해 **장식자(데코레이터)** 객체가 기존 객체를 감싸며, 원래 객체는 그대로 두고 추가적인 작업을 할 수 있게 해준다. 장식자는 원래 객체와 같은 인터페이스를 제공하므로 외부에서는 장식자를 구분하지 못한다. 또한, 장식자는 자신이 감싼 객체로 전달되는 요청을 가로채서, 그 사이에 부가적인 작업을 할 수 있으며, 이런 방식으로 **책임을 무한히 추가**할 수 있다.

**활용성**

-다른 개체 영향을 주지 않고 개개의 객체에 새로운 책임을 추가 하기 위해 사용

- 제거 할 수 있는 책임에 대해 사용

- 실제 상속으로 서브 클래스를 계속 만드는 방법이 실질적이지 못할 때 사용

**구조**

**참여자**

- Component: 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- ConcreteComponent: 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체
- Decorator: Component 객체에 대한 참조자를 관리하며 Component에 정의된 인터페이스를 만족하도록 인터페스 정의
- ConcreteDecorator: Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스

**협력 방법**

Decorator는 자신의 Component 객체 쪽으로 요청을 전달. 요청 전달 전 및 전달 후에 자신만의 추가 연산을 선택적으로 수행할 수도 있다.

**결과**

이익

1. 단순한 상속보다 설계 융통성을 더 많이 증대시킬 수 있다.
2.  클래스 계통의 상부측 클래스에 많은 기능이 누적 되는 상황을 피할 수 있다.  : 미리 구현할 필요없고 필요할 때마다 구현할 수 있음(미래 대비 유용함?)

부담

1. 장식자와 해당 그 장식자의 구성요소가 동일한 것은 아니다.
2. 장식자를 사용함으로써 작은 규모의 객체들이 많이 생긴다.

**구현**

구현시 고려사항

1. 인터페이스 일치시키기
2. 추상 클래스로 정의되는 Decorator 클래스 생략하기
3. Component 클래스는 가벼운 무게를 유지 하기 : 변수는 정의하지 않기
4. 객체의 겉 장을 변경할 것인가, 속을 변경할 것인가: Component 클래스가 복잡 무겁 → 전략 패턴, 겉을 변경하는 경우 → 데코레이터 패턴