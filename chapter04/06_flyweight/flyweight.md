### Flyweight

**의도**

: 중복되는 데이터를 공유함으로써 메모리 사용을 줄이고, 많은 객체를 효율적으로 관리하는 패턴

**활용성**

-응용프로그램이 대량의 객체를 사용해야 할 때 → 중복데이터 공유로 메모리를 아낄 수 있다!

-객체수가 너무 많아져 저장 비용이 너무 높아 질 때 → 주요 데이터와 부가적인 데이터를 나누고, 부가적인 데이터는 공유

-대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때

-부가적인 속성들을 제거 한 후 객체들을 조사해보니 객체 많은 묶음이 비교적 적은 수의 공유 된 객체로 대체 될 수 있을 때

-응용프로그램이 객체의 정체성을 의존 하지 않을 때

**구조**

**참여자**

- Flyweight: flyweight가 받아들일 수 있고, 부가적 상태에서 동작해야 하는 인터페이스 선언
- ConcreteFlyweight: Flyweight의 인터페이스를 구현하고 내부적으로 갖고 있어야 하는 상태에 대한 저장소 정의, 관리하는 어떤 상태라도 **본질적인 것(공유해야 하는 것)**이어야 함
- UnsharedConcreteFlyweight: 본질적이지 않은 것, 부가적인 것, 꼭 구현하지 않아도 괜찮다!
- FlyweightFactory: Flyweight 객체를 생성하고 관리, 플라이급 객체가 제대로 공유되도록 관리
- Client: 플라이급 객체에 대한 참조자를 관리하며 플라이급 객체의 부가적 상태를 저장

**협력 방법**

- 본질적인 상태와 부가적인 상태 구분하기
    - 본질적인 상태는 ConcreteFlyweight에 저장
    - 부가적인 상태는 사용자가 저장하거나 연산되어야 하는 다른 상태로 관리
- 사용자는 ConcreteFlyweight의 인스턴스를 직접 만들 수 없다.  → 공유를 위해서

**결과**

<저장소 절약으로 얻는 이점>

-공유 해야 하는 인스턴스의 전체 수를 줄일 수 있다. → 중복 객체수 줄어듬

-객체별 본질적 상태의 양을 줄일 수 있다.

-부가적인 상태는 연산되거나 저장 될 수 있다.

<단점>

-부가적 상태 만들기 위한 연산 시간 비용 발생

**구현**

-부과적 상태는 제외

-공유 할 객체를 관리