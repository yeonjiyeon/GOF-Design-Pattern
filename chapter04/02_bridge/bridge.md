### BRIDGE

**의도**

구현에서 추상을 분리하여 이들이 독립적으로 다양성을 가질 수 있도록 한다

**동기**

-추상 개념을 구체화 할 때 대부분 상속 사용→ 충분한 융통성 얻을 수 없다!

-추상적 개념과 구현을 분리해서 재용하거나 수정, 확장할 수 있어야 한다.

-bridge 패턴은 추상적 개념에 해당하는 클래스 계통과 구현에 해당하는 클래스 계통을 분리함으로써 문제를 해결한다.

**활용성**

- 추상적 개념과 이에 대한 구현 사이에 지속적인 종속 관계를 피하고 싶을 때: 런타임시 구현 방법 선택 혹은 구현 내용 변경하고 싶을 때
  -추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장 되어야 할 때

-추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무런 영향을 주지 않아야 할 때
-사용자에게 구현을 완벽하게 은닉하길 원할 때(c++)
Class 개통해서 class 수가 급증 하는 것을 방지 하고자 할 때 → 중첩된 일반화
-여러 객체들에 걸쳐 구현을 공유하고자 하며, 이런 사실을 사용자쪽에 공개하고 싶지 않을 때

**구조**

**참여자**

- Abstraction: 추상적 개념에 대한 인터페이스를 제공하고 객체 구현자에 대한 참조 자를 관리
- RefinedAbstraction: 추상적 개념에 정의된 인터페이스를 확장
- Implementor: 구현 클래스에 대한 인터페이스를 제공, 일반적으로 Implementor 인터페이스는 기본적 구현 연산을 수행며, Abtraction은 더 추상화된 서비스 관점의 인터페이스를 제공
- ConcreteImplementor: 인터페이스를 구현 하는 것 실제적인 구현 내용

**협력 방법**

-Abstraction클래스가 사용자 요청을 Implementor 객체에 전달

**결과**

-인터페이스(추상)와 구현 분리: Abstraction과 Implementor 분리는 컴파일 타임 의존성을 제거 할 수 있고 더 잘 구조화 된 시스템을 이끄는 계층화도 가능해 진다.
-확장성 제고
-구현 세부사항을 사용자에게서 숨기기

**구현**

-Implementor 하나만 둔다: **구**현이 오직 하나뿐이라면 브릿지 패턴이 불필요할 수 있으나 장기적으로 새로운 구현이 추가될 가능성이 있다면, 미리 분리하는 것이 좋다
-정확한 Implementor 객체를 생성 한다
-Implementor를 공유 한다
-다중 상속을 이용한다: 다중 상속을 이용할 수 있으나 진정한 의미의 브릿지 패턴이라 볼 수 없다.